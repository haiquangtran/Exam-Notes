# Querying Microsoft SQL Server 2012

## Transact-SQL (T-SQL)
  - T-SQL is the main language used to manage and manipulate data in Microsoft SQL Server. SQL Server also supports other languages, like C# and VB but T-SQL is usually the preferred language for data management and manipulation. 
    - T-SQL is a dialect of standard SQL. 
    - T-SQL is based on strong mathematical foundations. (Based on standard SQL, which in turn is based on the relational model, which is based on set theory and predicate logic.)
    - Follow the SQL standard:
      - <> over !=
      - CAST over CONVERT
      - ; at the end etc
  - A relation in the relational model refers to a relation as a table. The relational model is based on predicate logic and set logic.
  - **T-SQL vs SQL**
    - SQL is standard; T-SQL is the dialect of and extension to SQL that Microsoft implements in its RDBMS - SQL Server.
  - Write queries that interact with the table as a whole (not iteratively).
  - **T-SQL Deviations from SQL**
    - T-SQL is based more on multiset theory (bags or supersets) than on set theory. 
    - A table doesn't have to have a key.
    - Allows you to refer to ordinal positions of columns from the result in the ORDER BY clause i.e. ORDER BY 1; (1st column)
    - Allows defining result columns based on an expression without assigning a name to the target column. e.g. Select empid, firstname + ' ' + lastname FROM HR.EMployees. (We do not have to set the column name for firstname + lastname AS fullname, it just shows up empty for the column heading)
    - Allows a query to return multiple result columns with the same name. 
    - Uses three-valued predicate logic. True/False/Null. When a predicate comapres two values, if both are present, the result evaluates to either true or false, but if one is NULL, the result evalutes to a third logical value - Unknown.
    - NOTE: T-SQL provides tools/features to still do it the relational way. 

## Logical Query Processing
  - T-SQL is a declarative English-like language - You define what you want (the "what" part, the DB engine will figure out the "how" part) as opposed to how to achieve what you want. Therefore the keyed-in order of the query starts with the SELECT clause.
  - **Phases (In keyed-in order)**
    - SELECT
    - FROM
    - WHERE
    - GROUP BY
    - HAVING
    - ORDER BY
  - **Conceptual interpretation order (Logical query processing) is different for the above; it processes it like this**
    - FROM
    - WHERE (Cannot refer to aliases here because SELECT is after this)
    - GROUP BY
    - HAVING (Evaluated per group, whereas WHERE is evaluated before rows are grouped; Therefore is evaluated per row.)
    - SELECT
    - ORDER BY
  - T-SQL eavluates all expressions that appear in the same logical query processing phase in an all-at-once manner. 
    - SQL server won't necessarily physically process all expressions at the same point in time, but it has to produce a result as if it did (conceptually). This is different to other programming languages where it's usually evaluated from left to right. But T-SQL is different.

## Querying and Managing XML Data
  - You can use the FOR XML clause of the SELECT T-SQL statement to product XML.
  - Use the OPENXML function to shred XML to tables.
  - **XML**
    - Element-centric means that the attributes are all nested in their own elements
    - Attribute-centric means their are attributes on the element, rather than the attributes being nested. 
  - SQL Server includes support for XML:
    - Creating XML from relational data with a query and shredding XML into relational tabular format
    - SQL Server has native XML data type, can index it with specialized XML indexes, manipulate it using XML data type methods
  - **Producing XML from Relational Data**
    - **FOR XML RAW**
      - Does not give additional level of nesting.
      - In RAW mode, every row from returned rowsets converts to a single element named row, and columns translate to the attributes of this element. 
        - i.e. <row custid="1" companyname="YOLO" /> etc
      - You can enhance the RAW mode by renaming the row element, adding a ROOT element, including NAMESPACES, and making the XML returned element-centric.
        - i.e. <CustomerOrders> <Order custid="1" companyname="YOLO" /> </CustomerOrders> 
    - **FOR XML AUTO**
      - Gives you nice XML documents with nested elements.
      - In AUTO and RAW modes, you can use the keyword ELEMENTS to produce element-centric XML.
      - The WITH NAMESPACES clause, preceding the SELECT part of the query, defines namespaces and aliases in the returned XML. 
    - FOR XML clause comes after the ORDER BY clause in a query.
    - ORDER BY clause is important, without it the order of rows returned is unpredictable (weird XML document with repeated elements multiple times with just part of nested elements everytime etc). 
    - Order of the columns in the SELECT clause also influences the XML returned. SQL Server uses column order to determine the nesting of elements. The order should follow 1 to * relationships. 
    - XSD schema is called the inline schema. You return XSD with the **XMLSCHEMA(target_namespace)** directive. This schema is included inside the XML that is returned, before the actual XML data. If you only need schema, without the data, simply include a WHERE condition that no row can satisfy.
    - **FOR XML PATH**
      - The FOR XML clause has options of: the EXPLICIT and PATH options - you can manually define the XML returned. 
        - The EXPLICIT mode is included for backward compatibility only; it uses proprietary T-SQL for formatting XML.
        - The PATH mode uses standard XML XPath expressions to define the elements and attributes of the XML you are creating. 
      - In PATH mode, column names and aliases serve as XPath expressions. 
        - By default, every column becomes an element; if you want to generate attribute-centric XML - prefix the alias name with @
    - If you want to create XML with nested elements for child tables, you have to use subqueries in the SELECT part of the query in the PATH mode. 
  - **Shredding XML to Tables**
    - Converting XML to relational tables is known as shredding XML.
    - **OPENXML function**
      - Provides a rowset over in-memory XML documents by using DOM presentation. Before parsing the DOM, you need to prepare it. To prepare it, call the system stored procedure sys.sp_xml_preparedocument. After you shred the document, you must remove the DOM presentation by using the procedure sys.sp_xml_removedocument. 
      - Uses the following parameters:
        - An XML DOM document handle (int), returned by sp_xml_preparedocument
        - An XPath expression (rowpattern) to find the nodes you want to map to rows of a rowset returned
        - A description of the rowset returned
        - Mapping between XML nodes and rowset columns
      - Can map XML elements or attributes to rows and cols by using the WITH clause of the OPENXML function. 
      - Accepts an optional third parameter: flags
        - A flag of 1 means attribute-centric mapping
        - 2 means element-centric
        - 3 means both, however, flag value 3 is undocumented - best practice not to use it. 
        - Flag value 8 can be combined with values 1 and 2 (flag value of 11) with a bitwise logical OR operator to get both attribute and element centric mapping.
      - LOOK UP THIS PART AGAIN
  - **Querying XML Data with XQuery (RELOOK AT THIS SECTION)**
    - **XQuery**
      - Standard language for browsing XML instances and returning XML
      - Much richer than XPath expressions, an older standard, which you can use for simple navigation only.
      - XQuery allows you to navigate, loop over nodes, shapre the returned XML instance and more.
      - SQL Server DB engine processes XQuery inside T-SQL statements through XML data type methods. (Not all XQuery features are supported in SQL Server).
      - XQuery has it's own type system, has all of the commonly used types you would expect, and that you can use specific functions on specific types only. 
    - **Navigation**
      - Plenty of ways to navigate through an XML document with XQuery. Basic approach is to use XPath expressions. With XQuery can specifcy relative or absolute paths. 
        - for example: Node-name/child::element-name[@attribute-name=value]
        - **Axis**
          - Specifies the direction of travel. In the example the axis is child::, which specifies child nodes of the node from the previous step.
        - **Node test**
          - Specifies the criterion for selecting nodes. In the example, element-name is the node test; it selects only nodes named element-name
        - **Predicate**
          - Further narrows downt he search. In the example, there is one predicate: [@attribute-name=value], which selects only nodes that have an attribute named attribute-name with value value, such as [@orderid=10952]
          - Note: for the predicate example, there is a reference to the attribute:: axis; the at sign (@) is an abbreviation for the axis attribute::.
          - Can do predicates in sequences. However, if in sequences if one of them is true, then it returns in the whole sequence returning true
            - i.e. (1, 2, 3) = (2, 4) -- true, (1, 2, 3) = 1 -- true etc.
            - if this is confusing use value comparison operators (lt, gt, etc). These can only be used by themselves and not in sequence.
          - Supports conditional statements if, then, else etc
    - **FLWOR Expressions (XQuery)**
      - for, let, where, order by, and return (return lets you format the XQuery)
      - FLWOR expressions are actually a for each loop.
  - **Lesson Summary**
    - You can use the XQuery language inside T-SQL queries to query XML data
    - XQuery supports its own data types and functions
    - You use XPath expressions to navigate through an XML instance.
    - The real power of XQuery is in the FLWOR expressions

- **Using the XML Data Type**
  - XML is the standard format for exchanging data among different applications and platforms. Databases simply have to deal with it.
  - **When to use the XML Data type (RELOOK AT THIS)**
    - DB schema is sometimes volatile (dynamic/changes often). 
    - Data definition language (DDL) triggers and extended events returning different event information; each event returns data with a different schema. A conscious design decision was that DDL triggers return event information in XML format via the eventdata() function
    - XML showplan - can generate execution plan information in XML format by using the SET SHOWPLAN_XML and SET STATISTICS XML statements - It's easy to request and parse now. 
    - Another case is when data is sparse - you can represent it in XML. (Your data might have alot of nulls etc, in relational you might need to create unnecessary tables for these etc)
    - Could have reasons to use an XML model, since it supports hierarchical and sorted data.
      - RELOOK AT THE REST
      - The easiest way to create XML Schemas is to create relational tables first, then use the XMLSCHEMA option for the FOR XML clause.
  - **XML Indexes**
    - XML data type is actually a large object type. There can be up to 2 GB of data in every single column value. Scanning through the XML data sequentially is not a very efficient way of retrieving info.
    - Creating an index on a filtered column does a index seek operation rather than table scan.
    - Can also index XML columns with specialized XML indexes. 
    - Primary XML index: the first index you create on an XML column. This index contains a shredded persisted representation of the XML values. For each value in the column, the index creates several rows of data. After creating the primary index, you can create up to three other types of secondary xml indexes.
      - Can be created only on tables with a clustered primary key.
    - Secondary XML indexes: 
      - **PATH**
        - Useful if queries specify path expressions. It speeds up the exist() method better than the primary xml index. Also speeds up queries that use value() for a fully specified path.
      - **VALUE**
        - Useful if queries are value-based and the path is not fully specified or it includes a wildcard. 
      - **Property**
        - Useful for queries that retrieve one or more values from individual XML isntances by using the value() method.
  -**Lesson Summary**
    - XML data type is useful for many scenarios inside a relational database.
    - You can validate XML instances against a schema collection.
    - You can work with XML data through XML data type methods. 