# Querying Microsoft SQL Server 2012

## Transact-SQL (T-SQL)
  - T-SQL is the main language used to manage and manipulate data in Microsoft SQL Server. SQL Server also supports other languages, like C# and VB but T-SQL is usually the preferred language for data management and manipulation. 
    - T-SQL is a dialect of standard SQL. 
    - T-SQL is based on strong mathematical foundations. (Based on standard SQL, which in turn is based on the relational model, which is based on set theory and predicate logic.)
    - Follow the SQL standard:
      - <> over !=
      - CAST over CONVERT
      - ; at the end etc
  - A relation in the relational model refers to a relation as a table. The relational model is based on predicate logic and set logic.
  - **T-SQL vs SQL**
    - SQL is standard; T-SQL is the dialect of and extension to SQL that Microsoft implements in its RDBMS - SQL Server.
  - Write queries that interact with the table as a whole (not iteratively).
  - **T-SQL Deviations from SQL**
    - T-SQL is based more on multiset theory (bags or supersets) than on set theory. 
    - A table doesn't have to have a key.
    - Allows you to refer to ordinal positions of columns from the result in the ORDER BY clause i.e. ORDER BY 1; (1st column)
    - Allows defining result columns based on an expression without assigning a name to the target column. e.g. Select empid, firstname + ' ' + lastname FROM HR.EMployees. (We do not have to set the column name for firstname + lastname AS fullname, it just shows up empty for the column heading)
    - Allows a query to return multiple result columns with the same name. 
    - Uses three-valued predicate logic. True/False/Null. When a predicate comapres two values, if both are present, the result evaluates to either true or false, but if one is NULL, the result evalutes to a third logical value - Unknown.
    - NOTE: T-SQL provides tools/features to still do it the relational way. 

## Logical Query Processing
  - T-SQL is a declarative English-like language - You define what you want (the "what" part, the DB engine will figure out the "how" part) as opposed to how to achieve what you want. Therefore the keyed-in order of the query starts with the SELECT clause.
  - **Phases (In keyed-in order)**
    - SELECT
    - FROM
    - WHERE
    - GROUP BY
    - HAVING
    - ORDER BY
  - **Conceptual interpretation order (Logical query processing) is different for the above; it processes it like this**
    - FROM
    - WHERE (Cannot refer to aliases here because SELECT is after this)
    - GROUP BY
    - HAVING (Evaluated per group, whereas WHERE is evaluated before rows are grouped; Therefore is evaluated per row.)
    - SELECT
    - ORDER BY
  - T-SQL eavluates all expressions that appear in the same logical query processing phase in an all-at-once manner. 
    - SQL server won't necessarily physically process all expressions at the same point in time, but it has to produce a result as if it did (conceptually). This is different to other programming languages where it's usually evaluated from left to right. But T-SQL is different.

## Querying and Managing XML Data
  - You can use the FOR XML clause of the SELECT T-SQL statement to product XML.
  - Use the OPENXML function to shred XML to tables.
  - **XML**
    - Element-centric means that the attributes are all nested in their own elements
    - Attribute-centric means their are attributes on the element, rather than the attributes being nested. 
  - SQL Server includes support for XML:
    - Creating XML from relational data with a query and shredding XML into relational tabular format
    - SQL Server has native XML data type, can index it with specialized XML indexes, manipulate it using XML data type methods
  - **Producing XML from Relational Data**
    - **FOR XML RAW**
      - Does not give additional level of nesting.
      - In RAW mode, every row from returned rowsets converts to a single element named row, and columns translate to the attributes of this element. 
        - i.e. <row custid="1" companyname="YOLO" /> etc
      - You can enhance the RAW mode by renaming the row element, adding a ROOT element, including NAMESPACES, and making the XML returned element-centric.
        - i.e. <CustomerOrders> <Order custid="1" companyname="YOLO" /> </CustomerOrders> 
    - **FOR XML AUTO**
      - Gives you nice XML documents with nested elements.
      - In AUTO and RAW modes, you can use the keyword ELEMENTS to produce element-centric XML.
      - The WITH NAMESPACES clause, preceding the SELECT part of the query, defines namespaces and aliases in the returned XML. 
    - FOR XML clause comes after the ORDER BY clause in a query.
    - ORDER BY clause is important, without it the order of rows returned is unpredictable (weird XML document with repeated elements multiple times with just part of nested elements everytime etc). 
    - Order of the columns in the SELECT clause also influences the XML returned. SQL Server uses column order to determine the nesting of elements. The order should follow 1 to * relationships. 
    - XSD schema is called the inline schema. You return XSD with the **XMLSCHEMA(target_namespace)** directive. This schema is included inside the XML that is returned, before the actual XML data. If you only need schema, without the data, simply include a WHERE condition that no row can satisfy.
    - **FOR XML PATH**
      - The FOR XML clause has options of: the EXPLICIT and PATH options - you can manually define the XML returned. 
        - The EXPLICIT mode is included for backward compatibility only; it uses proprietary T-SQL for formatting XML.
        - The PATH mode uses standard XML XPath expressions to define the elements and attributes of the XML you are creating. 
      - In PATH mode, column names and aliases serve as XPath expressions. 
        - By default, every column becomes an element; if you want to generate attribute-centric XML - prefix the alias name with @
    - If you want to create XML with nested elements for child tables, you have to use subqueries in the SELECT part of the query in the PATH mode. 
  - **Shredding XML to Tables**
    - Converting XML to relational tables is known as shredding XML.
    - **OPENXML function**
      - Provides a rowset over in-memory XML documents by using DOM presentation. Before parsing the DOM, you need to prepare it. To prepare it, call the system stored procedure sys.sp_xml_preparedocument. After you shred the document, you must remove the DOM presentation by using the procedure sys.sp_xml_removedocument. 
      - Uses the following parameters:
        - An XML DOM document handle (int), returned by sp_xml_preparedocument
        - An XPath expression (rowpattern) to find the nodes you want to map to rows of a rowset returned
        - A description of the rowset returned
        - Mapping between XML nodes and rowset columns
      - Can map XML elements or attributes to rows and cols by using the WITH clause of the OPENXML function. 
      - Accepts an optional third parameter: flags
        - A flag of 1 means attribute-centric mapping
        - 2 means element-centric
        - 3 means both, however, flag value 3 is undocumented - best practice not to use it. 
        - Flag value 8 can be combined with values 1 and 2 (flag value of 11) with a bitwise logical OR operator to get both attribute and element centric mapping.
      - LOOK UP THIS PART AGAIN
  - **Querying XML Data with XQuery (RELOOK AT THIS SECTION)**
    - **XQuery**
      - Standard language for browsing XML instances and returning XML
      - Much richer than XPath expressions, an older standard, which you can use for simple navigation only.
      - XQuery allows you to navigate, loop over nodes, shapre the returned XML instance and more.
      - SQL Server DB engine processes XQuery inside T-SQL statements through XML data type methods. (Not all XQuery features are supported in SQL Server).
      - XQuery has it's own type system, has all of the commonly used types you would expect, and that you can use specific functions on specific types only. 
    - **Navigation**
      - Plenty of ways to navigate through an XML document with XQuery. Basic approach is to use XPath expressions. With XQuery can specifcy relative or absolute paths. 
        - for example: Node-name/child::element-name[@attribute-name=value]
        - **Axis**
          - Specifies the direction of travel. In the example the axis is child::, which specifies child nodes of the node from the previous step.
        - **Node test**
          - Specifies the criterion for selecting nodes. In the example, element-name is the node test; it selects only nodes named element-name
        - **Predicate**
          - Further narrows downt he search. In the example, there is one predicate: [@attribute-name=value], which selects only nodes that have an attribute named attribute-name with value value, such as [@orderid=10952]
          - Note: for the predicate example, there is a reference to the attribute:: axis; the at sign (@) is an abbreviation for the axis attribute::.
          - Can do predicates in sequences. However, if in sequences if one of them is true, then it returns in the whole sequence returning true
            - i.e. (1, 2, 3) = (2, 4) -- true, (1, 2, 3) = 1 -- true etc.
            - if this is confusing use value comparison operators (lt, gt, etc). These can only be used by themselves and not in sequence.
          - Supports conditional statements if, then, else etc
    - **FLWOR Expressions (XQuery)**
      - for, let, where, order by, and return (return lets you format the XQuery)
      - FLWOR expressions are actually a for each loop.
  - **Lesson Summary**
    - You can use the XQuery language inside T-SQL queries to query XML data
    - XQuery supports its own data types and functions
    - You use XPath expressions to navigate through an XML instance.
    - The real power of XQuery is in the FLWOR expressions

- **Using the XML Data Type**
  - XML is the standard format for exchanging data among different applications and platforms. Databases simply have to deal with it.
  - **When to use the XML Data type (RELOOK AT THIS)**
    - DB schema is sometimes volatile (dynamic/changes often). 
    - Data definition language (DDL) triggers and extended events returning different event information; each event returns data with a different schema. A conscious design decision was that DDL triggers return event information in XML format via the eventdata() function
    - XML showplan - can generate execution plan information in XML format by using the SET SHOWPLAN_XML and SET STATISTICS XML statements - It's easy to request and parse now. 
    - Another case is when data is sparse - you can represent it in XML. (Your data might have alot of nulls etc, in relational you might need to create unnecessary tables for these etc)
    - Could have reasons to use an XML model, since it supports hierarchical and sorted data.
      - RELOOK AT THE REST
      - The easiest way to create XML Schemas is to create relational tables first, then use the XMLSCHEMA option for the FOR XML clause.
  - **XML Indexes**
    - XML data type is actually a large object type. There can be up to 2 GB of data in every single column value. Scanning through the XML data sequentially is not a very efficient way of retrieving info.
    - Creating an index on a filtered column does a index seek operation rather than table scan.
    - Can also index XML columns with specialized XML indexes. 
    - Primary XML index: the first index you create on an XML column. This index contains a shredded persisted representation of the XML values. For each value in the column, the index creates several rows of data. After creating the primary index, you can create up to three other types of secondary xml indexes.
      - Can be created only on tables with a clustered primary key.
    - Secondary XML indexes: 
      - **PATH**
        - Useful if queries specify path expressions. It speeds up the exist() method better than the primary xml index. Also speeds up queries that use value() for a fully specified path.
      - **VALUE**
        - Useful if queries are value-based and the path is not fully specified or it includes a wildcard. 
      - **Property**
        - Useful for queries that retrieve one or more values from individual XML isntances by using the value() method.
  -**Lesson Summary**
    - XML data type is useful for many scenarios inside a relational database.
    - You can validate XML instances against a schema collection.
    - You can work with XML data through XML data type methods. 

**Create Database Objects section**
- Types of tables
  - Partitioned tables
    - data has been horizontally divided into units which may be spread across more than one filegroup in a database. 
    - By default, SQL Server 2016 supports up to 15,000 partitions.
  - Temporary Tables
    - stored in tempdb
    - There are local and global temporary tables.
    - **local**
      - have single number sign (#) as the first character of their names
      - Only visible to the current connection for the user and are deleted when the user disconnects to the instance of the SQL server
    - **global**
      - have two number signs (##) as the first characters of their names
      - deleted when all users referencing the table disconnect from the instance of the SQL Server. 
  - System tables
    - Users cannot directly query or update the system tables
    - special set of tables that defines the configuration of the server
    - Info made available through views
  - Wide tables
    - Use sparse columns to increase the total of columns that a table can have to 30,000. 
    - Sparse columsn are ordinary cols that have an optimized storage for null values. 
    - They reduce the space requirements for null values at the cost of more overhead to retrieve nonnull values.
    - Most of the data in any particular row should be NULL. 
 - Views
   - virtual table whose contents are defined by a query.
   - Unless indexed, a view does not exist as a stored set of data values in a database.
   - Rows and cols of data come from tables referenced in the query defining the view, and are produced dynamically whent he view is referenced.
   - Can be used as security mechanism by letting users access data through the view, without granting the users permissions to directly access the underlying base tables of the view. 
   - **Indexed views**
     - Is materialized and the definition has been computed with the resulting data stored just like a table
     - Create a unique clustered index on it to do this
     - Indexed views work best for queries that aggregate many rows but are not suited for underlying datasets that are frequently updated.
  - **Partitioned views**
    - Partitioned view joins horizontally partitioned data from a set of member tables across one or more servers. 
 - Index
   - **Clustered index**
     - Special type of index that reorders the way the rows in the table are physically stored on the disk in the same order as the index.
     - Therefore a table can have only one clustered index
     - Generally faster to read from a clustered index if you want to get back all the columns. You do not have to go first to the index and then to the table.
     - Can be more than one column, but by default a column with a primary key already has a clustered index
     - Writing to a table with a clustered index can be slower, if there is a need to rearrange the data
   - **Non clustered index**
     - There is a second list that has pointers to the physical rows. You can have many non clustered indexes, although each new index will increase the time it takes to write new records.

**Work with Data section**
- PIVOT
  - Used to change table-valued expressions into another table.
  - Rotates a table-valued expression by turning the unique values from one column in the expression into multiple columns in the output. 
  - Performs aggregations where they are required on any remaining column values that are wanted in the final output
  - SELECT ..., FROM ..., PIVOT (... FOR ... IN ()) AS ..., <Optional order by>
- UNPIVOT
  - Performs opposite operation to pivot
  - Rotates columns of a table-valued expression into column values. 
- **Ranking functions**
  - Return a ranking value for each row in a partition. i.e. SELECT RANK() OVER (ORDER BY PostalCode) AS "Rank", NTILE(4) OVER (ORDER BY PostalCode) As Quartile
  - **RANK**
    - Same values are given the same rank
    - However, some rank values may not be sequential (i.e. if there are 3 of the same values then that would be rank 1, the next rank would be rank 4).
  - **NTILE**
    - Splits rows in an ordered partition into a specified number of groups. The groups are numbered, starting at one. 
  - **DENSE_RANK**
    - Same as rank but the ranking is sequential (There are no gaps in the rankings) i.e 1,2,3 
  - **ROW_NUMBER**
    - Sequence of rows (1,2,3,4,5 etc)
- **Data types**
  - NEWSEQUENTIALID 
    - Creates a GUID that is greater than any GUID previously generated by this function on a specified computer since Windows was started. 
    - After restarting Windows, the GUID can start again from a lower range, but is still globally unique
    - When a GUID col is used as a row identifier, newsequentialid can be faster than using newid function (because newid function causes random activity and uses fewer cached data pages)
    - NEWSEQUENTIALID also helps to compeltely fill the data and index pages
    - If privacy is a concern do not use this function as it's possible to guess the next value generated.
