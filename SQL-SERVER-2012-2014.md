# Querying Microsoft SQL Server 2012

## Transact-SQL (T-SQL)
  - T-SQL is the main language used to manage and manipulate data in Microsoft SQL Server. SQL Server also supports other languages, like C# and VB but T-SQL is usually the preferred language for data management and manipulation. 
    - T-SQL is a dialect of standard SQL. 
    - T-SQL is based on strong mathematical foundations. (Based on standard SQL, which in turn is based on the relational model, which is based on set theory and predicate logic.)
    - Follow the SQL standard:
      - <> over !=
      - CAST over CONVERT
      - ; at the end etc
  - A relation in the relational model refers to a relation as a table. The relational model is based on predicate logic and set logic.
  - **T-SQL vs SQL**
    - SQL is standard; T-SQL is the dialect of and extension to SQL that Microsoft implements in its RDBMS - SQL Server.
  - Write queries that interact with the table as a whole (not iteratively).
  - **T-SQL Deviations from SQL**
    - T-SQL is based more on multiset theory (bags or supersets) than on set theory. 
    - A table doesn't have to have a key.
    - Allows you to refer to ordinal positions of columns from the result in the ORDER BY clause i.e. ORDER BY 1; (1st column)
    - Allows defining result columns based on an expression without assigning a name to the target column. e.g. Select empid, firstname + ' ' + lastname FROM HR.EMployees. (We do not have to set the column name for firstname + lastname AS fullname, it just shows up empty for the column heading)
    - Allows a query to return multiple result columns with the same name. 
    - Uses three-valued predicate logic. True/False/Null. When a predicate comapres two values, if both are present, the result evaluates to either true or false, but if one is NULL, the result evalutes to a third logical value - Unknown.
    - NOTE: T-SQL provides tools/features to still do it the relational way. 

## Logical Query Processing
  - T-SQL is a declarative English-like language - You define what you want (the "what" part, the DB engine will figure out the "how" part) as opposed to how to achieve what you want. Therefore the keyed-in order of the query starts with the SELECT clause.
  - **Phases (In keyed-in order)**
    - SELECT
    - FROM
    - WHERE
    - GROUP BY
    - HAVING
    - ORDER BY
  - **Conceptual interpretation order (Logical query processing) is different for the above; it processes it like this**
    - FROM
    - WHERE (Cannot refer to aliases here because SELECT is after this)
    - GROUP BY
    - HAVING (Evaluated per group, whereas WHERE is evaluated before rows are grouped; Therefore is evaluated per row.)
    - SELECT
    - ORDER BY
  - T-SQL eavluates all expressions that appear in the same logical query processing phase in an all-at-once manner. 
    - SQL server won't necessarily physically process all expressions at the same point in time, but it has to produce a result as if it did (conceptually). This is different to other programming languages where it's usually evaluated from left to right. But T-SQL is different.

## Querying and Managing XML Data
  - You can use the FOR XML clause of the SELECT T-SQL statement to product XML.
  - Use the OPENXML function to shred XML to tables.
  - **XML**
    - Element-centric means that the attributes are all nested in their own elements
    - Attribute-centric means their are attributes on the element, rather than the attributes being nested. 
  - SQL Server includes support for XML:
    - Creating XML from relational data with a query and shredding XML into relational tabular format
    - SQL Server has native XML data type, can index it with specialized XML indexes, manipulate it using XML data type methods
  - **Producing XML from Relational Data**
    - **FOR XML RAW**
      - Does not give additional level of nesting.
      - In RAW mode, every row from returned rowsets converts to a single element named row, and columns translate to the attributes of this element. 
        - i.e. <row custid="1" companyname="YOLO" /> etc
      - You can enhance the RAW mode by renaming the row element, adding a ROOT element, including NAMESPACES, and making the XML returned element-centric.
        - i.e. <CustomerOrders> <Order custid="1" companyname="YOLO" /> </CustomerOrders> 
    - **FOR XML AUTO**
      - Gives you nice XML documents with nested elements.
      - In AUTO and RAW modes, you can use the keyword ELEMENTS to produce element-centric XML.
      - The WITH NAMESPACES clause, preceding the SELECT part of the query, defines namespaces and aliases in the returned XML. 
    - FOR XML clause comes after the ORDER BY clause in a query.
    - ORDER BY clause is important, without it the order of rows returned is unpredictable (weird XML document with repeated elements multiple times with just part of nested elements everytime etc). 
    - Order of the columns in the SELECT clause also influences the XML returned. SQL Server uses column order to determine the nesting of elements. The order should follow 1 to * relationships. 
    - XSD schema is called the inline schema. You return XSD with the **XMLSCHEMA(target_namespace)** directive. This schema is included inside the XML that is returned, before the actual XML data. If you only need schema, without the data, simply include a WHERE condition that no row can satisfy.
    - **FOR XML PATH**
      - The FOR XML clause has options of: the EXPLICIT and PATH options - you can manually define the XML returned. 
        - The EXPLICIT mode is included for backward compatibility only; it uses proprietary T-SQL for formatting XML.
        - The PATH mode uses standard XML XPath expressions to define the elements and attributes of the XML you are creating. 
      - In PATH mode, column names and aliases serve as XPath expressions. 
        - By default, every column becomes an element; if you want to generate attribute-centric XML - prefix the alias name with @
    - If you want to create XML with nested elements for child tables, you have to use subqueries in the SELECT part of the query in the PATH mode. 
  - **Shredding XML to Tables**
    - Converting XML to relational tables is known as shredding XML.
    - **OPENXML function**
      - Provides a rowset over in-memory XML documents by using DOM presentation. Before parsing the DOM, you need to prepare it. To prepare it, call the system stored procedure sys.sp_xml_preparedocument. After you shred the document, you must remove the DOM presentation by using the procedure sys.sp_xml_removedocument. 
      - Uses the following parameters:
        - An XML DOM document handle (int), returned by sp_xml_preparedocument
        - An XPath expression (rowpattern) to find the nodes you want to map to rows of a rowset returned
        - A description of the rowset returned
        - Mapping between XML nodes and rowset columns
      - Can map XML elements or attributes to rows and cols by using the WITH clause of the OPENXML function. 
      - Accepts an optional third parameter: flags
        - A flag of 1 means attribute-centric mapping
        - 2 means element-centric
        - 3 means both, however, flag value 3 is undocumented - best practice not to use it. 
        - Flag value 8 can be combined with values 1 and 2 (flag value of 11) with a bitwise logical OR operator to get both attribute and element centric mapping.
      - LOOK UP THIS PART AGAIN
  - **Querying XML Data with XQuery**
    - 